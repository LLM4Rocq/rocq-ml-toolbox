"""Generated by atdpy from type definitions in protocol.atd.

This implements classes for the types defined in 'protocol.atd', providing
methods and functions to convert data from/to JSON.
"""

# Disable flake8 entirely on this file:
# flake8: noqa

# Import annotations to allow forward references
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, NoReturn, Optional, Tuple, Union

import json

############################################################################
# Private functions
############################################################################


def _atd_missing_json_field(type_name: str, json_field_name: str) -> NoReturn:
    raise ValueError(
        f"missing field '{json_field_name}'" f" in JSON object of type '{type_name}'"
    )


def _atd_bad_json(expected_type: str, json_value: Any) -> NoReturn:
    value_str = str(json_value)
    if len(value_str) > 200:
        value_str = value_str[:200] + "…"

    raise ValueError(
        f"incompatible JSON value where"
        f" type '{expected_type}' was expected: '{value_str}'"
    )


def _atd_bad_python(expected_type: str, json_value: Any) -> NoReturn:
    value_str = str(json_value)
    if len(value_str) > 200:
        value_str = value_str[:200] + "…"

    raise ValueError(
        f"incompatible Python value where"
        f" type '{expected_type}' was expected: '{value_str}'"
    )


def _atd_read_unit(x: Any) -> None:
    if x is None:
        return x
    else:
        _atd_bad_json("unit", x)


def _atd_read_bool(x: Any) -> bool:
    if isinstance(x, bool):
        return x
    else:
        _atd_bad_json("bool", x)


def _atd_read_int(x: Any) -> int:
    if isinstance(x, int):
        return x
    else:
        _atd_bad_json("int", x)


def _atd_read_float(x: Any) -> float:
    if isinstance(x, (int, float)):
        return x
    else:
        _atd_bad_json("float", x)


def _atd_read_string(x: Any) -> str:
    if isinstance(x, str):
        return x
    else:
        _atd_bad_json("str", x)


def _atd_read_list(read_elt: Callable[[Any], Any]) -> Callable[[List[Any]], List[Any]]:
    def read_list(elts: List[Any]) -> List[Any]:
        if isinstance(elts, list):
            return [read_elt(elt) for elt in elts]
        else:
            _atd_bad_json("array", elts)

    return read_list


def _atd_read_assoc_array_into_dict(
    read_key: Callable[[Any], Any],
    read_value: Callable[[Any], Any],
) -> Callable[[List[Any]], Dict[Any, Any]]:
    def read_assoc(elts: List[List[Any]]) -> Dict[str, Any]:
        if isinstance(elts, list):
            return {read_key(elt[0]): read_value(elt[1]) for elt in elts}
        else:
            _atd_bad_json("array", elts)
            raise AssertionError("impossible")  # keep mypy happy

    return read_assoc


def _atd_read_assoc_object_into_dict(
    read_value: Callable[[Any], Any],
) -> Callable[[Dict[str, Any]], Dict[str, Any]]:
    def read_assoc(elts: Dict[str, Any]) -> Dict[str, Any]:
        if isinstance(elts, dict):
            return {_atd_read_string(k): read_value(v) for k, v in elts.items()}
        else:
            _atd_bad_json("object", elts)
            raise AssertionError("impossible")  # keep mypy happy

    return read_assoc


def _atd_read_assoc_object_into_list(
    read_value: Callable[[Any], Any],
) -> Callable[[Dict[str, Any]], List[Tuple[str, Any]]]:
    def read_assoc(elts: Dict[str, Any]) -> List[Tuple[str, Any]]:
        if isinstance(elts, dict):
            return [(_atd_read_string(k), read_value(v)) for k, v in elts.items()]
        else:
            _atd_bad_json("object", elts)
            raise AssertionError("impossible")  # keep mypy happy

    return read_assoc


def _atd_read_nullable(
    read_elt: Callable[[Any], Any],
) -> Callable[[Optional[Any]], Optional[Any]]:
    def read_nullable(x: Any) -> Any:
        if x is None:
            return None
        else:
            return read_elt(x)

    return read_nullable


def _atd_read_option(
    read_elt: Callable[[Any], Any],
) -> Callable[[Optional[Any]], Optional[Any]]:
    def read_option(x: Any) -> Any:
        if x == "None":
            return None
        elif isinstance(x, List) and len(x) == 2 and x[0] == "Some":
            return read_elt(x[1])
        else:
            _atd_bad_json("option", x)
            raise AssertionError("impossible")  # keep mypy happy

    return read_option


def _atd_write_unit(x: Any) -> None:
    if x is None:
        return x
    else:
        _atd_bad_python("unit", x)


def _atd_write_bool(x: Any) -> bool:
    if isinstance(x, bool):
        return x
    else:
        _atd_bad_python("bool", x)


def _atd_write_int(x: Any) -> int:
    if isinstance(x, int):
        return x
    else:
        _atd_bad_python("int", x)


def _atd_write_float(x: Any) -> float:
    if isinstance(x, (int, float)):
        return x
    else:
        _atd_bad_python("float", x)


def _atd_write_string(x: Any) -> str:
    if isinstance(x, str):
        return x
    else:
        _atd_bad_python("str", x)


def _atd_write_list(
    write_elt: Callable[[Any], Any],
) -> Callable[[List[Any]], List[Any]]:
    def write_list(elts: List[Any]) -> List[Any]:
        if isinstance(elts, list):
            return [write_elt(elt) for elt in elts]
        else:
            _atd_bad_python("list", elts)

    return write_list


def _atd_write_assoc_dict_to_array(
    write_key: Callable[[Any], Any], write_value: Callable[[Any], Any]
) -> Callable[[Dict[Any, Any]], List[Tuple[Any, Any]]]:
    def write_assoc(elts: Dict[str, Any]) -> List[Tuple[str, Any]]:
        if isinstance(elts, dict):
            return [(write_key(k), write_value(v)) for k, v in elts.items()]
        else:
            _atd_bad_python("Dict[str, <value type>]]", elts)
            raise AssertionError("impossible")  # keep mypy happy

    return write_assoc


def _atd_write_assoc_dict_to_object(
    write_value: Callable[[Any], Any],
) -> Callable[[Dict[str, Any]], Dict[str, Any]]:
    def write_assoc(elts: Dict[str, Any]) -> Dict[str, Any]:
        if isinstance(elts, dict):
            return {_atd_write_string(k): write_value(v) for k, v in elts.items()}
        else:
            _atd_bad_python("Dict[str, <value type>]", elts)
            raise AssertionError("impossible")  # keep mypy happy

    return write_assoc


def _atd_write_assoc_list_to_object(
    write_value: Callable[[Any], Any],
) -> Callable[[List[Any]], Dict[str, Any]]:
    def write_assoc(elts: List[List[Any]]) -> Dict[str, Any]:
        if isinstance(elts, list):
            return {_atd_write_string(elt[0]): write_value(elt[1]) for elt in elts}
        else:
            _atd_bad_python("List[Tuple[<key type>, <value type>]]", elts)
            raise AssertionError("impossible")  # keep mypy happy

    return write_assoc


def _atd_write_nullable(
    write_elt: Callable[[Any], Any],
) -> Callable[[Optional[Any]], Optional[Any]]:
    def write_nullable(x: Any) -> Any:
        if x is None:
            return None
        else:
            return write_elt(x)

    return write_nullable


def _atd_write_option(
    write_elt: Callable[[Any], Any],
) -> Callable[[Optional[Any]], Optional[Any]]:
    def write_option(x: Any) -> Any:
        if x is None:
            return "None"
        else:
            return ["Some", write_elt(x)]

    return write_option


############################################################################
# Public classes
############################################################################


from pytanque.protocol import Range


@dataclass
class RangedSpan:
    """Original type: ranged_span = { ... }"""

    range: Range
    span: Optional[str] = None

    @classmethod
    def from_json(cls, x: Any) -> "RangedSpan":
        if isinstance(x, dict):
            return cls(
                range=(
                    Range.from_json(x["range"])
                    if "range" in x
                    else _atd_missing_json_field("RangedSpan", "range")
                ),
                span=_atd_read_string(x["span"]) if "span" in x else None,
            )
        else:
            _atd_bad_json("RangedSpan", x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res["range"] = (lambda x: x.to_json())(self.range)
        if self.span is not None:
            res["span"] = _atd_write_string(self.span)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> "RangedSpan":
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class CompletionStatus:
    """Original type: completion_status = { ... }"""

    status: List[str]
    range: Range

    @classmethod
    def from_json(cls, x: Any) -> "CompletionStatus":
        if isinstance(x, dict):
            return cls(
                status=(
                    _atd_read_list(_atd_read_string)(x["status"])
                    if "status" in x
                    else _atd_missing_json_field("CompletionStatus", "status")
                ),
                range=(
                    Range.from_json(x["range"])
                    if "range" in x
                    else _atd_missing_json_field("CompletionStatus", "range")
                ),
            )
        else:
            _atd_bad_json("CompletionStatus", x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res["status"] = _atd_write_list(_atd_write_string)(self.status)
        res["range"] = (lambda x: x.to_json())(self.range)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> "CompletionStatus":
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class FlecheDocument:
    """Original type: fleche_document = { ... }"""

    spans: List[RangedSpan]
    completed: CompletionStatus

    @classmethod
    def from_json(cls, x: Any) -> "FlecheDocument":
        if isinstance(x, dict):
            return cls(
                spans=(
                    _atd_read_list(RangedSpan.from_json)(x["spans"])
                    if "spans" in x
                    else _atd_missing_json_field("FlecheDocument", "spans")
                ),
                completed=(
                    CompletionStatus.from_json(x["completed"])
                    if "completed" in x
                    else _atd_missing_json_field("FlecheDocument", "completed")
                ),
            )
        else:
            _atd_bad_json("FlecheDocument", x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res["spans"] = _atd_write_list((lambda x: x.to_json()))(self.spans)
        res["completed"] = (lambda x: x.to_json())(self.completed)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> "FlecheDocument":
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)
